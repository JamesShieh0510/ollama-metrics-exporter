<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama ÈõÜÁæ§Á∂≤Áµ°ÊãìÊí≤Âúñ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: #f5f7fa;
            color: #333;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            min-width: 280px;
            z-index: 100;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        #info-panel h2 {
            margin-bottom: 15px;
            color: #2563eb;
            font-size: 16px;
            font-weight: 600;
        }
        
        .node-info {
            margin: 8px 0;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #2563eb;
        }
        
        .node-info strong {
            color: #1e40af;
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 12px;
        }
        
        .stat-label {
            color: #6b7280;
        }
        
        .stat-value {
            color: #059669;
            font-weight: 600;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            z-index: 100;
        }
        
        #controls h3 {
            margin-bottom: 10px;
            font-size: 13px;
            color: #374151;
        }
        
        #controls button {
            background: #2563eb;
            color: #fff;
            border: none;
            padding: 6px 12px;
            margin: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        #controls button:hover {
            background: #1d4ed8;
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            font-size: 12px;
            color: #374151;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            background: #10b981;
        }
        
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            font-size: 12px;
        }
        
        #legend h3 {
            margin-bottom: 10px;
            font-size: 13px;
            color: #374151;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            color: #6b7280;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #e0e0e0;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="info-panel">
            <h2>üìä ÁØÄÈªûÁãÄÊÖã</h2>
            <div id="nodes-info"></div>
        </div>
        
        <div id="controls">
            <h3>ÊéßÂà∂</h3>
            <button onclick="resetCamera()">ÈáçÁΩÆË¶ñËßí</button>
            <button onclick="toggleAutoRotate()">Ëá™ÂãïÊóãËΩâ</button>
        </div>
        
        <div id="status">
            <span class="status-indicator"></span>
            <span id="status-text">Ê≠£Âú®ÈÄ£Êé•...</span>
        </div>
        
        <div id="legend">
            <h3>Âúñ‰æã</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: #3b82f6;"></div>
                <span>Router (Á∂≤Èóú)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #10b981;"></div>
                <span>Node (Ê¥ªË∫ç)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9ca3af;"></div>
                <span>Node (Á©∫Èñí)</span>
            </div>
            <div class="legend-item">
                <div style="width: 16px; height: 2px; background: #f59e0b; margin-right: 8px; border-radius: 1px;"></div>
                <span>Á∂≤Áµ°ÈÄ£Êé•</span>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // ÈÖçÁΩÆ
        const CONFIG = {
            exporterUrls: {
                node1: 'http://192.168.50.158:9101/metrics',
                node2: 'http://192.168.50.31:9101/metrics',
                node3: 'http://192.168.50.94:9101/metrics',
                node4: 'http://192.168.50.155:9101/metrics',
                router: null
            },
            updateInterval: 2000,
            nodePositions: {
                router: { x: 0, y: 0, z: 0 },
                node1: { x: 4, y: 0, z: 0 },
                node2: { x: -4, y: 0, z: 0 },
                node3: { x: 0, y: 0, z: 4 },
                node4: { x: 0, y: 0, z: -4 }
            },
            nodeColors: {
                router: 0x3b82f6,    // ËóçËâ≤
                active: 0x10b981,      // Á∂†Ëâ≤
                idle: 0x9ca3af        // ÁÅ∞Ëâ≤
            },
            // Á°¨‰ª∂Ë¶èÊ†ºÂíåIP‰ø°ÊÅØ
            nodeInfo: {
                router: {
                    name: 'Router',
                    ip: '192.168.50.1',
                    hostname: 'router',
                    spec: 'Gateway'
                },
                node1: {
                    name: 'Node1',
                    ip: '192.168.50.158',
                    hostname: 'm3max',
                    hostnames: ['m3max.local', 'm3max-128gb.local'],
                    spec: 'M3 Max - 128GB'
                },
                node2: {
                    name: 'Node2',
                    ip: '192.168.50.31',
                    hostname: 'm1max',
                    hostnames: ['m1max.local', 'm1max-64gb.local'],
                    spec: 'M1 Max - 64GB'
                },
                node3: {
                    name: 'Node3',
                    ip: '192.168.50.94',
                    hostname: 'm1',
                    hostnames: ['m1.local', 'm1-16gb.local'],
                    spec: 'M1 - 16GB'
                },
                node4: {
                    name: 'Node4',
                    ip: '192.168.50.155',
                    hostname: 'i7',
                    hostnames: ['i74080.local', 'i7g13-4080-32gb.local'],
                    spec: 'i7-4080 - 32GB'
                }
            }
        };
        
        // Â†¥ÊôØË®≠ÁΩÆ
        let scene, camera, renderer, controls;
        let nodeMeshes = {};
        let edgeLines = {};
        let edgeLabels = {}; // ÈÄ£Êé•Á∑ö‰∏äÁöÑÊ®ôÁ∞Ω
        let detailLabels = {}; // Ë©≥Á¥∞‰ø°ÊÅØÊ®ôÁ∞ΩÔºàhoverÊôÇÈ°ØÁ§∫Ôºâ
        let raycaster, mouse;
        let hoveredNode = null;
        let autoRotate = false;
        let previousData = {}; // ‰øùÂ≠ò‰∏ä‰∏ÄÊ¨°ÁöÑÊï∏ÊìöÁî®ÊñºË®àÁÆó rate
        
        // ÂàùÂßãÂåñ Three.js Â†¥ÊôØ
        function initScene() {
            // ÂâµÂª∫Â†¥ÊôØ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);
            
            // ÂâµÂª∫Áõ∏Ê©ü
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(10, 8, 10);
            camera.lookAt(0, 0, 0);
            
            // ÂâµÂª∫Ê∏≤ÊüìÂô®ÔºàÈ´òË≥™ÈáèË®≠ÁΩÆÔºâ
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // ÈôêÂà∂ÊúÄÂ§ßDPI‰ª•ÈÅøÂÖçÊÄßËÉΩÂïèÈ°å
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ‰ΩøÁî®ËªüÈô∞ÂΩ±
            
            // Ê∑ªÂä†ËªåÈÅìÊéßÂà∂Âô®
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            
            // ÂàùÂßãÂåñÂ∞ÑÁ∑öÊ™¢Ê∏¨Âô®ÔºàÁî®ÊñºhoverÊ™¢Ê∏¨Ôºâ
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Ê∑ªÂä†ÂÖâÊ∫êÔºàÂ∞àÊ•≠Á∂≤Áµ°ÊãìÊí≤È¢®Ê†ºÔºâ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // ÂâµÂª∫ÁØÄÈªû
            createNodes();
            
            // ÂâµÂª∫ÈÄ£Êé•Á∑ö
            createEdges();
            
            // Ê∑ªÂä†Âú∞Èù¢Á∂≤Ê†ºÔºàÁ∂≤Áµ°ÊãìÊí≤È¢®Ê†ºÔºâ
            const gridHelper = new THREE.GridHelper(20, 20, 0xd1d5db, 0xe5e7eb);
            gridHelper.position.y = -0.1;
            scene.add(gridHelper);
            
            // Ê∑ªÂä†Âú∞Èù¢Âπ≥Èù¢
            const planeGeometry = new THREE.PlaneGeometry(30, 30);
            const planeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.8,
                metalness: 0.1
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);
            
            // ÈñãÂßãÂãïÁï´Âæ™Áí∞
            animate();
        }
        
        // ÂâµÂª∫ÊñáÂ≠óÁ¥ãÁêÜÔºàÊîØÊåÅÂ§öË°åÔºåÈ´òË≥™ÈáèÊäóÈã∏ÈΩíÔºåÂûÇÁõ¥È°ØÁ§∫Ôºâ
        function createTextTexture(lines, options = {}) {
            // ‰ΩøÁî®È´òDPI‰æÜÊèêÈ´òÊñáÂ≠óÊ∏ÖÊô∞Â∫¶
            const dpr = window.devicePixelRatio || 2;
            const scale = Math.max(2, dpr); // Ëá≥Â∞ë2ÂÄçÂàÜËæ®Áéá
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d', { 
                alpha: true,
                antialias: true,
                willReadFrequently: false
            });
            
            const fontSize = options.fontSize || 32;
            const smallFontSize = options.smallFontSize || 24;
            const fontFamily = options.fontFamily || 'Arial, sans-serif';
            const fontWeight = options.fontWeight || 'bold';
            const textColor = options.textColor || '#1e40af';
            const smallTextColor = options.smallTextColor || '#6b7280';
            const backgroundColor = options.backgroundColor || 'rgba(255, 255, 255, 0.95)';
            const padding = options.padding || 15;
            const lineHeight = options.lineHeight || 1.3;
            const vertical = options.vertical !== false; // ÈªòË™çÂûÇÁõ¥È°ØÁ§∫
            
            // ÂïüÁî®È´òË≥™ÈáèÊñáÂ≠óÊ∏≤Êüì
            context.textBaseline = 'alphabetic';
            context.textAlign = 'center';
            
            if (vertical) {
                // ÂûÇÁõ¥È°ØÁ§∫ÔºöÂ∞áÊñáÂ≠óÊóãËΩâ90Â∫¶
                // Ë®àÁÆóÊñáÂ≠óÂØ¨Â∫¶ÂíåÈ´òÂ∫¶Ôºà‰ΩøÁî®ÂØ¶ÈöõÂ≠óÈ´îÂ§ßÂ∞èÔºâ
                context.font = `${fontWeight} ${fontSize * scale}px ${fontFamily}`;
                let maxWidth = 0;
                let totalHeight = 0;
                lines.forEach((line, index) => {
                    const font = index === 0 ? 
                        `${fontWeight} ${fontSize * scale}px ${fontFamily}` : 
                        `${smallFontSize * scale}px ${fontFamily}`;
                    context.font = font;
                    const metrics = context.measureText(line.text || line);
                    maxWidth = Math.max(maxWidth, metrics.width);
                    const lineHeightValue = index === 0 ? fontSize * scale : smallFontSize * scale;
                    totalHeight += lineHeightValue * (index === 0 ? 1.1 : lineHeight);
                });
                
                // ÂûÇÁõ¥È°ØÁ§∫ÔºöÂØ¨Â∫¶ÂíåÈ´òÂ∫¶‰∫íÊèõ
                const canvasWidth = totalHeight + padding * 2 * scale;
                const canvasHeight = maxWidth + padding * 2 * scale;
                
                // Ë®≠ÁΩÆÈ´òÂàÜËæ®Áéácanvas
                canvas.width = canvasWidth * 1.1;
                canvas.height = canvasHeight * 1.1;
                canvas.style.width = (canvas.width / scale) + 'px';
                canvas.style.height = (canvas.height / scale) + 'px';
                
                // Á∏ÆÊîæcontext‰ª•ÂåπÈÖçÈ´òÂàÜËæ®Áéá
                context.scale(scale, scale);
                
                // ÂïüÁî®ÊäóÈã∏ÈΩíÂíåÊñáÂ≠óÂπ≥Êªë
                context.imageSmoothingEnabled = true;
                context.imageSmoothingQuality = 'high';
                
                // Áπ™Ë£ΩËÉåÊôØ
                if (backgroundColor) {
                    context.fillStyle = backgroundColor;
                    context.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
                }
                
                // Áπ™Ë£ΩÂûÇÁõ¥ÊñáÂ≠óÔºàÂ§öË°åÔºâ
                let y = padding;
                lines.forEach((line, index) => {
                    const isFirstLine = index === 0;
                    const isTitle = line.isTitle === true;
                    const currentFontSize = (isFirstLine || isTitle) ? fontSize : smallFontSize;
                    const font = (isFirstLine || isTitle) ? 
                        `${fontWeight} ${fontSize}px ${fontFamily}` : 
                        `${smallFontSize}px ${fontFamily}`;
                    const color = (isFirstLine || isTitle) ? textColor : smallTextColor;
                    
                    context.save();
                    
                    // ÁßªÂãïÂà∞ÊñáÂ≠ó‰ΩçÁΩÆ
                    const centerX = canvas.width / scale / 2;
                    context.translate(centerX, y);
                    // ÊóãËΩâ90Â∫¶ÔºàÈ†ÜÊôÇÈáùÔºâ
                    context.rotate(Math.PI / 2);
                    
                    context.font = font;
                    context.fillStyle = color;
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    
                    // ‰ΩøÁî®ÊñáÂ≠óÈô∞ÂΩ±‰æÜÂ¢ûÂº∑Ê∏ÖÊô∞Â∫¶
                    context.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    context.shadowBlur = 1;
                    context.shadowOffsetX = 0.5;
                    context.shadowOffsetY = 0.5;
                    
                    const text = line.text || line;
                    context.fillText(text, 0, 0);
                    
                    context.restore();
                    
                    // ÈáçÁΩÆÈô∞ÂΩ±
                    context.shadowColor = 'transparent';
                    context.shadowBlur = 0;
                    context.shadowOffsetX = 0;
                    context.shadowOffsetY = 0;
                    
                    if (isFirstLine || isTitle) {
                        y += fontSize * 1.1; // Ê®ôÈ°åË°åÈñìË∑ù
                    } else {
                        y += smallFontSize * lineHeight;
                    }
                });
            } else {
                // Ê∞¥Âπ≥È°ØÁ§∫ÔºàÂéüÊúâÈÇèËºØÔºâ
                context.font = `${fontWeight} ${fontSize * scale}px ${fontFamily}`;
                let maxWidth = 0;
                lines.forEach((line, index) => {
                    const font = index === 0 ? 
                        `${fontWeight} ${fontSize * scale}px ${fontFamily}` : 
                        `${smallFontSize * scale}px ${fontFamily}`;
                    context.font = font;
                    const metrics = context.measureText(line.text || line);
                    maxWidth = Math.max(maxWidth, metrics.width);
                });
                
                const totalHeight = (fontSize * scale) + (lines.length - 1) * (smallFontSize * scale * lineHeight);
                
                canvas.width = (maxWidth + padding * 2 * scale) * 1.1;
                canvas.height = (totalHeight + padding * 2 * scale) * 1.1;
                canvas.style.width = (canvas.width / scale) + 'px';
                canvas.style.height = (canvas.height / scale) + 'px';
                
                context.scale(scale, scale);
                context.imageSmoothingEnabled = true;
                context.imageSmoothingQuality = 'high';
                
                if (backgroundColor) {
                    context.fillStyle = backgroundColor;
                    context.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
                }
                
                let y = padding + fontSize;
                lines.forEach((line, index) => {
                    const isFirstLine = index === 0;
                    const isTitle = line.isTitle === true;
                    const font = (isFirstLine || isTitle) ? 
                        `${fontWeight} ${fontSize}px ${fontFamily}` : 
                        `${smallFontSize}px ${fontFamily}`;
                    const color = (isFirstLine || isTitle) ? textColor : smallTextColor;
                    
                    context.font = font;
                    context.fillStyle = color;
                    context.textAlign = 'center';
                    context.textBaseline = 'alphabetic';
                    
                    context.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    context.shadowBlur = 1;
                    context.shadowOffsetX = 0.5;
                    context.shadowOffsetY = 0.5;
                    
                    const text = line.text || line;
                    context.fillText(text, (canvas.width / scale) / 2, y);
                    
                    context.shadowColor = 'transparent';
                    context.shadowBlur = 0;
                    context.shadowOffsetX = 0;
                    context.shadowOffsetY = 0;
                    
                    if (isFirstLine || isTitle) {
                        y += fontSize * 1.1;
                    } else {
                        y += smallFontSize * lineHeight;
                    }
                });
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            texture.needsUpdate = true;
            return texture;
        }
        
        // ÂâµÂª∫ÁØÄÈªûÔºàÊúçÂãôÂô®Ê©üÊû∂È¢®Ê†ºÔºâ
        function createNodes() {
            const nodeNames = ['router', 'node1', 'node2', 'node3', 'node4'];
            
            nodeNames.forEach(nodeName => {
                const pos = CONFIG.nodePositions[nodeName];
                
                // ÂâµÂª∫ÊúçÂãôÂô®Ê©üÊû∂Ê®£ÂºèÁöÑÁØÄÈªûÔºàÁ´ãÊñπÈ´îÔºâ
                const width = nodeName === 'router' ? 0.8 : 0.6;
                const height = nodeName === 'router' ? 1.2 : 1.0;
                const depth = 0.6;
                
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({
                    color: nodeName === 'router' ? CONFIG.nodeColors.router : CONFIG.nodeColors.idle,
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: 0x000000
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pos.x, height / 2, pos.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.nodeName = nodeName;
                scene.add(mesh);
                nodeMeshes[nodeName] = mesh;
                
                // Ê∑ªÂä†È†ÇÈÉ®ÊåáÁ§∫Ááà
                const indicatorGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 16);
                const indicatorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x9ca3af,
                    emissive: 0x000000
                });
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                indicator.position.set(0, height / 2 + 0.05, 0);
                indicator.userData.isIndicator = true;
                mesh.add(indicator);
                
                // ÂâµÂª∫Á∞°ÂñÆÁöÑÁØÄÈªûÂêçÁ®±Ê®ôÁ∞ΩÔºàÂßãÁµÇÈ°ØÁ§∫ÔºåÂè™È°ØÁ§∫ÁØÄÈªûÂêçÁ®±Ôºâ
                const nodeInfo = CONFIG.nodeInfo[nodeName];
                const displayName = nodeInfo ? nodeInfo.name : nodeName.toUpperCase();
                
                const simpleLabelTexture = createTextTexture([{ text: displayName }], {
                    fontSize: 28,
                    fontFamily: 'Arial, sans-serif',
                    fontWeight: 'bold',
                    textColor: '#1e40af',
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    padding: 8,
                    vertical: false // Ê∞¥Âπ≥È°ØÁ§∫
                });
                
                const simpleLabelMaterial = new THREE.MeshBasicMaterial({
                    map: simpleLabelTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                const simpleLabelGeometry = new THREE.PlaneGeometry(1.0, 0.25);
                const simpleLabel = new THREE.Mesh(simpleLabelGeometry, simpleLabelMaterial);
                simpleLabel.position.set(0, height + 0.35, 0);
                simpleLabel.userData.isLabel = true;
                mesh.add(simpleLabel);
                
                // ÂâµÂª∫Ë©≥Á¥∞‰ø°ÊÅØÊ®ôÁ∞ΩÔºàhoverÊôÇÈ°ØÁ§∫ÔºåÂàùÂßãÈö±ËóèÔºâ
                if (nodeInfo) {
                    const detailLabelLines = [];
                    // Á¨¨‰∏ÄË°åÔºöIPÂú∞ÂùÄÔºàËºÉÂ§ßÔºâ
                    detailLabelLines.push({ text: nodeInfo.ip, isTitle: true });
                    // Á¨¨‰∫åË°åÔºöÁ°¨‰ª∂Ë¶èÊ†º
                    if (nodeInfo.spec) {
                        detailLabelLines.push({ text: nodeInfo.spec, isTitle: false });
                    }
                    // Á¨¨‰∏âË°åÔºö‰∏ªÊ©üÂêç
                    if (nodeInfo.hostname) {
                        detailLabelLines.push({ text: nodeInfo.hostname, isTitle: false });
                    }
                    
                    const detailLabelTexture = createTextTexture(detailLabelLines, {
                        fontSize: 22,
                        smallFontSize: 16,
                        fontFamily: 'Arial, sans-serif',
                        fontWeight: 'bold',
                        textColor: '#1e40af',
                        smallTextColor: '#6b7280',
                        backgroundColor: 'rgba(255, 255, 255, 0.98)',
                        padding: 12,
                        lineHeight: 1.3,
                        vertical: false // Ê∞¥Âπ≥È°ØÁ§∫
                    });
                    
                    const detailLabelMaterial = new THREE.MeshBasicMaterial({
                        map: detailLabelTexture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    
                    const detailLabelWidth = 2.0;
                    const detailLabelHeight = detailLabelLines.length * 0.22 + 0.2;
                    const detailLabelGeometry = new THREE.PlaneGeometry(detailLabelWidth, detailLabelHeight);
                    const detailLabel = new THREE.Mesh(detailLabelGeometry, detailLabelMaterial);
                    // Â∞áË©≥Á¥∞Ê®ôÁ∞ΩÊîæÂú®Á∞°ÂñÆÊ®ôÁ∞Ω‰∏äÊñπÔºåÈÅøÂÖçÈáçÁñä
                    detailLabel.position.set(0, height + 0.35 + detailLabelHeight / 2 + 0.15, 0);
                    detailLabel.visible = false; // ÂàùÂßãÈö±Ëóè
                    detailLabel.userData.isDetailLabel = true;
                    mesh.add(detailLabel);
                    detailLabels[nodeName] = detailLabel;
                }
                
                // Ê∑ªÂä†hoverÊ™¢Ê∏¨
                mesh.userData.isNode = true;
                mesh.userData.nodeName = nodeName;
            });
        }
        
        // ÂâµÂª∫ÈÄ£Êé•Á∑öÔºàÁ∂≤Áµ°Á∑öÈ¢®Ê†ºÔºåÊîØÊåÅÂèØËÆäÁ≤óÁ¥∞Ôºâ
        function createEdges() {
            const nodeNames = ['node1', 'node2', 'node3', 'node4'];
            
            nodeNames.forEach(nodeName => {
                const sourcePos = CONFIG.nodePositions[nodeName];
                const targetPos = CONFIG.nodePositions.router;
                
                // Ë®àÁÆóÂÖ©Èªû‰πãÈñìÁöÑË∑ùÈõ¢ÂíåÊñπÂêë
                const start = new THREE.Vector3(sourcePos.x, 0.6, sourcePos.z);
                const end = new THREE.Vector3(targetPos.x, 0.6, targetPos.z);
                const distance = start.distanceTo(end);
                const midPoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                
                // ‰ΩøÁî®CylinderGeometryÂâµÂª∫ÂèØËÆäÁ≤óÁ¥∞ÁöÑÁ∑öÊ¢ù
                const initialRadius = 0.02;
                const cylinderGeometry = new THREE.CylinderGeometry(initialRadius, initialRadius, distance, 8);
                
                // ÊóãËΩâÂúìÊü±È´îÂ∞çÈΩäÂÖ©Èªû
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                const axis = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, direction);
                
                const material = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    transparent: true,
                    opacity: 0.4,
                    metalness: 0.3,
                    roughness: 0.7
                });
                
                const cylinder = new THREE.Mesh(cylinderGeometry, material);
                cylinder.position.copy(midPoint);
                cylinder.setRotationFromQuaternion(quaternion);
                scene.add(cylinder);
                
                edgeLines[nodeName] = { 
                    mesh: cylinder, 
                    start: start, 
                    end: end, 
                    distance: distance,
                    initialRadius: initialRadius 
                };
                
                // Âú®ÈÄ£Êé•Á∑ö‰∏≠ÈñìÂâµÂª∫ÈÄ£Êé•Êï∏Ê®ôÁ∞Ω
                const labelTexture = createTextTexture([{ text: '0' }], {
                    fontSize: 20,
                    fontFamily: 'Arial, sans-serif',
                    fontWeight: 'bold',
                    textColor: '#ffffff',
                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                    padding: 6,
                    vertical: false // Ê∞¥Âπ≥È°ØÁ§∫
                });
                
                const labelMaterial = new THREE.MeshBasicMaterial({
                    map: labelTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                const labelGeometry = new THREE.PlaneGeometry(0.3, 0.15);
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                label.position.copy(midPoint);
                label.position.y += 0.1; // Á®çÂæÆÊä¨È´ò‰∏ÄÈªû
                label.userData.isEdgeLabel = true;
                scene.add(label);
                edgeLabels[nodeName] = label;
            });
        }
        
        // Êõ¥Êñ∞ÁØÄÈªûÂ§ñËßÄ
        function updateNodes(data) {
            Object.keys(nodeMeshes).forEach(nodeName => {
                const mesh = nodeMeshes[nodeName];
                const nodeData = data[nodeName] || { connections: 0, sentRate: 0, recvRate: 0 };
                
                // Ê†πÊìöÈÄ£Êé•Êï∏Ë™øÊï¥È°èËâ≤ÂíåÊåáÁ§∫Ááà
                const isActive = (nodeData.connections || 0) > 0;
                
                if (nodeName === 'router') {
                    mesh.material.color.setHex(CONFIG.nodeColors.router);
                } else {
                    mesh.material.color.setHex(isActive ? CONFIG.nodeColors.active : CONFIG.nodeColors.idle);
                }
                
                // Êõ¥Êñ∞ÊåáÁ§∫Ááà
                const indicator = mesh.children.find(child => child.userData.isIndicator);
                if (indicator) {
                    indicator.material.color.setHex(isActive ? 0x10b981 : 0x9ca3af);
                    indicator.material.emissive.setHex(isActive ? 0x064e3b : 0x000000);
                }
            });
        }
        
        // Êõ¥Êñ∞ÈÄ£Êé•Á∑öÔºàÂåÖÊã¨Á≤óÁ¥∞ÂíåÊ®ôÁ∞ΩÔºâ
        function updateEdges(data) {
            Object.keys(edgeLines).forEach(nodeName => {
                const edge = edgeLines[nodeName];
                const nodeData = data[nodeName] || { connections: 0, sentRate: 0, recvRate: 0 };
                const totalRate = (nodeData.sentRate || 0) + (nodeData.recvRate || 0);
                const connections = nodeData.connections || 0;
                
                // Ê†πÊìöÊµÅÈáèË™øÊï¥Á∑öÊ¢ùÈ°èËâ≤ÂíåÈÄèÊòéÂ∫¶
                if (totalRate > 0) {
                    edge.mesh.material.color.setHex(0x10b981); // Á∂†Ëâ≤Ë°®Á§∫ÊúâÊµÅÈáè
                    edge.mesh.material.opacity = Math.min(0.4 + totalRate / 50000, 0.9);
                } else {
                    edge.mesh.material.color.setHex(0xf59e0b); // Ê©ôËâ≤Ë°®Á§∫ÁÑ°ÊµÅÈáè
                    edge.mesh.material.opacity = 0.2;
                }
                
                // Ê†πÊìöÁ∏ΩÊµÅÈáèË™øÊï¥Á∑öÊ¢ùÁ≤óÁ¥∞Ôºà0.02 Âà∞ 0.08Ôºâ
                const minRadius = 0.02;
                const maxRadius = 0.08;
                const rateFactor = Math.min(totalRate / 100000, 1); // 100KB/s ÁÇ∫ÊúÄÂ§ßÂÄº
                const radius = minRadius + (maxRadius - minRadius) * rateFactor;
                
                // Êõ¥Êñ∞ÂúìÊü±È´îÁ≤óÁ¥∞
                edge.mesh.scale.set(radius / edge.initialRadius, 1, radius / edge.initialRadius);
                
                // Êõ¥Êñ∞ÈÄ£Êé•Êï∏Ê®ôÁ∞Ω
                if (edgeLabels[nodeName]) {
                    const label = edgeLabels[nodeName];
                    const newTexture = createTextTexture([{ text: connections.toString() }], {
                        fontSize: 20,
                        fontFamily: 'Arial, sans-serif',
                        fontWeight: 'bold',
                        textColor: '#ffffff',
                        backgroundColor: connections > 0 ? 'rgba(16, 185, 129, 0.8)' : 'rgba(0, 0, 0, 0.7)',
                        padding: 6,
                        vertical: false // ÂûÇÁõ¥È°ØÁ§∫
                    });
                    label.material.map.dispose();
                    label.material.map = newTexture;
                    label.material.needsUpdate = true;
                }
            });
        }
        
        // Ëß£Êûê Prometheus metrics
        function parseMetrics(text, nodeName) {
            const data = { connections: 0, sentTotal: 0, recvTotal: 0 };
            const lines = text.split('\n');
            
            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith('#') || !line) return;
                
                // Ëß£Êûê metric - ÊîØÊåÅÂ§öÁ®ÆÊ†ºÂºè
                let match = line.match(/^([a-z_]+)\{([^}]+)\}\s+([0-9.eE+-]+)/);
                if (!match) {
                    // ÂòóË©¶‰∏çÂ∏∂Ê®ôÁ∞ΩÁöÑÊ†ºÂºè
                    match = line.match(/^([a-z_]+)\s+([0-9.eE+-]+)/);
                    if (match) {
                        const metricName = match[1];
                        const value = parseFloat(match[2]);
                        if (metricName === 'ollama_bytes_sent_total') {
                            data.sentTotal = value;
                        } else if (metricName === 'ollama_bytes_recv_total') {
                            data.recvTotal = value;
                        }
                    }
                    return;
                }
                
                const metricName = match[1];
                const labels = match[2];
                const value = parseFloat(match[3]);
                
                // Ëß£Êûê labels
                const nodeMatch = labels.match(/node="([^"]+)"/);
                if (nodeMatch && nodeMatch[1] === nodeName) {
                    if (metricName === 'ollama_connections') {
                        const stateMatch = labels.match(/state="([^"]+)"/);
                        if (stateMatch && stateMatch[1] === 'ESTABLISHED') {
                            data.connections = value;
                        }
                    } else if (metricName === 'ollama_bytes_sent_total') {
                        data.sentTotal = value;
                    } else if (metricName === 'ollama_bytes_recv_total') {
                        data.recvTotal = value;
                    }
                }
            });
            
            return data;
        }
        
        // Áç≤ÂèñÂñÆÂÄã exporter ÁöÑ metrics
        async function fetchSingleExporter(url, nodeName) {
            try {
                const response = await fetch(url, { mode: 'cors' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const text = await response.text();
                const parsed = parseMetrics(text, nodeName);
                
                // Ë®àÁÆó rateÔºàËàá‰∏ä‰∏ÄÊ¨°ÁöÑÂÄºÊØîËºÉÔºâ
                const prev = previousData[nodeName] || { sentTotal: 0, recvTotal: 0 };
                const timeDiff = CONFIG.updateInterval / 1000; // Áßí
                
                const result = {
                    connections: parsed.connections,
                    sentTotal: parsed.sentTotal,
                    recvTotal: parsed.recvTotal,
                    sentRate: Math.max(0, (parsed.sentTotal - prev.sentTotal) / timeDiff),
                    recvRate: Math.max(0, (parsed.recvTotal - prev.recvTotal) / timeDiff)
                };
                
                // ‰øùÂ≠òÁï∂ÂâçÂÄº‰æõ‰∏ãÊ¨°‰ΩøÁî®
                previousData[nodeName] = {
                    sentTotal: parsed.sentTotal,
                    recvTotal: parsed.recvTotal
                };
                
                return result;
            } catch (error) {
                console.warn(`ÁÑ°Ê≥ïÁç≤Âèñ ${nodeName} ÁöÑÊï∏Êìö:`, error);
                return null;
            }
        }
        
        // Áç≤ÂèñÊâÄÊúâ metrics Êï∏Êìö
        async function fetchMetrics() {
            const allData = {};
            let successCount = 0;
            
            if (CONFIG.exporterUrls) {
                const promises = Object.entries(CONFIG.exporterUrls).map(async ([nodeName, url]) => {
                    if (!url) {
                        // router ÊòØËôõÊì¨ÁØÄÈªûÔºåË®àÁÆóÁ∏ΩÂíå
                        const totalConnections = Object.keys(allData)
                            .filter(k => k !== 'router' && k.startsWith('node'))
                            .reduce((sum, k) => sum + (allData[k]?.connections || 0), 0);
                        allData[nodeName] = { 
                            connections: totalConnections, 
                            sentRate: 0, 
                            recvRate: 0 
                        };
                        return;
                    }
                    
                    const nodeData = await fetchSingleExporter(url, nodeName);
                    if (nodeData) {
                        allData[nodeName] = nodeData;
                        successCount++;
                    } else {
                        allData[nodeName] = { connections: 0, sentRate: 0, recvRate: 0 };
                    }
                });
                
                await Promise.all(promises);
                
                // ÈáçÊñ∞Ë®àÁÆó router ÁöÑÈÄ£Êé•Êï∏
                const totalConnections = Object.keys(allData)
                    .filter(k => k !== 'router' && k.startsWith('node'))
                    .reduce((sum, k) => sum + (allData[k]?.connections || 0), 0);
                if (allData.router) {
                    allData.router.connections = totalConnections;
                }
            }
            
            if (successCount === 0) {
                document.getElementById('status-text').textContent = 
                    `‚ö†Ô∏è ÁÑ°Ê≥ïÈÄ£Êé•Âà∞ exporter | Ê™¢Êü• exporter ÊòØÂê¶ÈÅãË°å`;
            } else {
                document.getElementById('status-text').textContent = 
                    `‚úÖ Â∑≤ÈÄ£Êé• ${successCount} ÂÄãÁØÄÈªû | ÊúÄÂæåÊõ¥Êñ∞: ${new Date().toLocaleTimeString()}`;
            }
            
            updateNodes(allData);
            updateEdges(allData);
            updateInfoPanel(allData);
            
            return allData;
        }
        
        // Êõ¥Êñ∞‰ø°ÊÅØÈù¢Êùø
        function updateInfoPanel(data) {
            const container = document.getElementById('nodes-info');
            container.innerHTML = '';
            
            const nodeNames = ['router', 'node1', 'node2', 'node3', 'node4'];
            nodeNames.forEach(nodeName => {
                const nodeData = data[nodeName] || { connections: 0, sentRate: 0, recvRate: 0 };
                const totalRate = nodeData.sentRate + nodeData.recvRate;
                const nodeInfo = CONFIG.nodeInfo[nodeName] || {};
                
                const div = document.createElement('div');
                div.className = 'node-info';
                
                // ÊßãÂª∫Á°¨‰ª∂‰ø°ÊÅØ
                let hardwareInfo = '';
                if (nodeInfo.spec) {
                    hardwareInfo = `<div class="stat" style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(0,0,0,0.1);">
                        <span class="stat-label" style="font-size: 11px; color: #9ca3af;">Á°¨‰ª∂Ë¶èÊ†º:</span>
                        <span class="stat-value" style="font-size: 11px; color: #2563eb;">${nodeInfo.spec}</span>
                    </div>`;
                }
                
                let hostnameInfo = '';
                if (nodeInfo.hostname) {
                    hostnameInfo = `<div class="stat" style="font-size: 11px;">
                        <span class="stat-label" style="color: #9ca3af;">‰∏ªÊ©üÂêç:</span>
                        <span class="stat-value" style="color: #6b7280;">${nodeInfo.hostname}</span>
                    </div>`;
                }
                
                let hostnamesInfo = '';
                if (nodeInfo.hostnames && nodeInfo.hostnames.length > 0) {
                    hostnamesInfo = `<div class="stat" style="font-size: 10px; margin-top: 2px;">
                        <span class="stat-label" style="color: #9ca3af;">Âà•Âêç:</span>
                        <span class="stat-value" style="color: #6b7280; font-size: 10px;">${nodeInfo.hostnames.join(', ')}</span>
                    </div>`;
                }
                
                div.innerHTML = `
                    <strong>${nodeInfo.name || nodeName.toUpperCase()}</strong>
                    ${nodeInfo.ip ? `<div class="stat" style="font-size: 11px; margin-bottom: 4px;">
                        <span class="stat-label" style="color: #9ca3af;">IP:</span>
                        <span class="stat-value" style="color: #2563eb; font-weight: 600;">${nodeInfo.ip}</span>
                    </div>` : ''}
                    ${hostnameInfo}
                    ${hostnamesInfo}
                    ${hardwareInfo}
                    <div class="stat" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1);">
                        <span class="stat-label">ÈÄ£Êé•Êï∏:</span>
                        <span class="stat-value">${Math.round(nodeData.connections || 0)}</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">ÁôºÈÄÅÈÄüÁéá:</span>
                        <span class="stat-value">${formatBytes(nodeData.sentRate || 0)}/s</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Êé•Êî∂ÈÄüÁéá:</span>
                        <span class="stat-value">${formatBytes(nodeData.recvRate || 0)}/s</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Á∏ΩÊµÅÈáè:</span>
                        <span class="stat-value">${formatBytes(totalRate)}/s</span>
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        // Ê†ºÂºèÂåñÂ≠óÁØÄÊï∏
        function formatBytes(bytes) {
            if (bytes === 0 || isNaN(bytes)) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        // Êõ¥Êñ∞Ê®ôÁ∞ΩÊúùÂêëÔºàËÆìÊ®ôÁ∞ΩÂßãÁµÇÈù¢ÂêëÁõ∏Ê©üÔºâ
        function updateLabels() {
            Object.values(nodeMeshes).forEach(mesh => {
                const label = mesh.children.find(child => child.userData.isLabel);
                if (label) {
                    label.lookAt(camera.position);
                }
                const detailLabel = mesh.children.find(child => child.userData.isDetailLabel);
                if (detailLabel) {
                    detailLabel.lookAt(camera.position);
                }
            });
            
            // Êõ¥Êñ∞ÈÄ£Êé•Á∑öÊ®ôÁ∞ΩÊúùÂêë
            Object.values(edgeLabels).forEach(label => {
                label.lookAt(camera.position);
            });
        }
        
        // ËôïÁêÜÈº†Ê®ôÁßªÂãïÔºàhoverÊ™¢Ê∏¨Ôºâ
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            // Âè™Ê™¢Ê∏¨ÁØÄÈªûÊú¨Ë∫´Ôºå‰∏çÂåÖÊã¨Â≠êÂ∞çË±°ÔºàÊ®ôÁ∞Ω„ÄÅÊåáÁ§∫ÁáàÁ≠âÔºâ
            const nodeObjects = Object.values(nodeMeshes);
            const intersects = raycaster.intersectObjects(nodeObjects, false);
            
            // Èö±ËóèÊâÄÊúâË©≥Á¥∞Ê®ôÁ∞Ω
            Object.values(detailLabels).forEach(label => {
                label.visible = false;
            });
            
            // È°ØÁ§∫hoverÁöÑÁØÄÈªûÁöÑË©≥Á¥∞Ê®ôÁ∞Ω
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                
                // Á¢∫‰øùÊòØÁØÄÈªûÊú¨Ë∫´
                if (intersected.userData.isNode) {
                    const nodeName = intersected.userData.nodeName;
                    if (detailLabels[nodeName]) {
                        detailLabels[nodeName].visible = true;
                        hoveredNode = nodeName;
                    }
                }
            } else {
                hoveredNode = null;
            }
        }
        
        // ÂãïÁï´Âæ™Áí∞
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                const time = Date.now() * 0.0003;
                camera.position.x = Math.cos(time) * 15;
                camera.position.z = Math.sin(time) * 15;
                camera.position.y = 8;
                camera.lookAt(0, 0, 0);
            }
            
            // Êõ¥Êñ∞Ê®ôÁ∞ΩÊúùÂêë
            updateLabels();
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ÊéßÂà∂ÂáΩÊï∏
        function resetCamera() {
            camera.position.set(10, 8, 10);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }
        
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
        }
        
        // Á™óÂè£Â§ßÂ∞èË™øÊï¥
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Ê∑ªÂä†Èº†Ê®ôÁßªÂãï‰∫ã‰ª∂Áõ£ËÅΩ
        window.addEventListener('mousemove', onMouseMove);
        
        // ÂàùÂßãÂåñ
        initScene();
        
        // ÂÆöÊúüÁç≤ÂèñÊï∏Êìö
        fetchMetrics();
        setInterval(fetchMetrics, CONFIG.updateInterval);
    </script>
</body>
</html>
