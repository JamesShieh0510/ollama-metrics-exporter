<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama ÈõÜÁæ§Á∂≤Áµ°ÊãìÊí≤Âúñ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: #f5f7fa;
            color: #333;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            min-width: 280px;
            z-index: 100;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        #info-panel h2 {
            margin-bottom: 15px;
            color: #2563eb;
            font-size: 16px;
            font-weight: 600;
        }
        
        .node-info {
            margin: 8px 0;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #2563eb;
        }
        
        .node-info strong {
            color: #1e40af;
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 12px;
        }
        
        .stat-label {
            color: #6b7280;
        }
        
        .stat-value {
            color: #059669;
            font-weight: 600;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            z-index: 100;
        }
        
        #controls h3 {
            margin-bottom: 10px;
            font-size: 13px;
            color: #374151;
        }
        
        #controls button {
            background: #2563eb;
            color: #fff;
            border: none;
            padding: 6px 12px;
            margin: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        #controls button:hover {
            background: #1d4ed8;
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            font-size: 12px;
            color: #374151;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            background: #10b981;
        }
        
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            font-size: 12px;
        }
        
        #legend h3 {
            margin-bottom: 10px;
            font-size: 13px;
            color: #374151;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            color: #6b7280;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #e0e0e0;
        }
        
        /* Ê®°ÂûãÂàóË°®Ê®°ÊÄÅÊ°ÜÊ†∑Âºè */
        #model-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        #model-modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            max-height: 80vh;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .modal-header h2 {
            margin: 0;
            color: #1e40af;
            font-size: 20px;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6b7280;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .modal-close:hover {
            background: #f3f4f6;
            color: #1f2937;
        }
        
        .model-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .model-item {
            padding: 16px;
            background: #f9fafb;
            border-radius: 8px;
            border-left: 4px solid #2563eb;
            transition: all 0.2s;
        }
        
        .model-item:hover {
            background: #f3f4f6;
            transform: translateX(4px);
        }
        
        .model-name {
            font-weight: 600;
            color: #1e40af;
            font-size: 15px;
            margin-bottom: 8px;
        }
        
        .model-details {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 12px;
            color: #6b7280;
        }
        
        .model-detail-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .model-detail-label {
            color: #9ca3af;
        }
        
        .model-detail-value {
            color: #374151;
            font-weight: 500;
        }
        
        .model-status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }
        
        .model-status-badge.loaded {
            background: #d1fae5;
            color: #065f46;
        }
        
        .model-status-badge.not-loaded {
            background: #f3f4f6;
            color: #6b7280;
        }
        
        .model-status-badge::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .model-status-badge.loaded::before {
            background: #10b981;
        }
        
        .model-status-badge.not-loaded::before {
            background: #9ca3af;
        }
        
        .loading-spinner {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #9ca3af;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="info-panel">
            <h2>üìä ÁØÄÈªûÁãÄÊÖã</h2>
            <div id="nodes-info"></div>
        </div>
        
        <div id="controls">
            <h3>ÊéßÂà∂</h3>
            <button onclick="resetCamera()">ÈáçÁΩÆË¶ñËßí</button>
            <button onclick="toggleAutoRotate()">Ëá™ÂãïÊóãËΩâ</button>
        </div>
        
        <div id="status">
            <span class="status-indicator"></span>
            <span id="status-text">Ê≠£Âú®ÈÄ£Êé•...</span>
        </div>
        
        <div id="legend">
            <h3>Âúñ‰æã</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: #3b82f6;"></div>
                <span>Router (Á∂≤Èóú)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #10b981;"></div>
                <span>Node (Ê¥ªË∫ç)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9ca3af;"></div>
                <span>Node (Á©∫Èñí)</span>
            </div>
            <div class="legend-item">
                <div style="width: 16px; height: 2px; background: #f59e0b; margin-right: 8px; border-radius: 1px;"></div>
                <span>Á∂≤Áµ°ÈÄ£Êé•</span>
            </div>
        </div>
        
        <!-- Ê®°ÂûãÂàóË°®Ê®°ÊÄÅÊ°Ü -->
        <div id="model-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="modal-title">ÁØÄÈªûÊ®°ÂûãÂàóË°®</h2>
                    <button class="modal-close" onclick="closeModelModal()">&times;</button>
                </div>
                <div id="modal-body">
                    <div class="loading-spinner">ËºâÂÖ•‰∏≠...</div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // ÈÖçÁΩÆÔºàÂ∞áÂæû API ÂãïÊÖãÂä†ËºâÔºâ
        const CONFIG = {
            exporterUrls: {
                router: null  // router ÊòØËôõÊì¨ÁØÄÈªû
            },
            updateInterval: 2000,
            nodePositions: {
                router: { x: 0, y: 0, z: 0 }  // router ÂßãÁµÇÂú®‰∏≠ÂøÉ
            },
            nodeColors: {
                router: 0x3b82f6,    // ËóçËâ≤
                active: 0x10b981,      // Á∂†Ëâ≤
                idle: 0x9ca3af,        // ÁÅ∞Ëâ≤
                external: 0xf59e0b     // Ê©ôËâ≤ÔºàÂ§ñÈÉ®ÁØÄÈªûÔºâ
            },
            // Á°¨‰ª∂Ë¶èÊ†ºÂíåIP‰ø°ÊÅØÔºàÂ∞áÂæû API ÂãïÊÖãÂä†ËºâÔºâ
            nodeInfo: {
                router: {
                    name: 'Gateway',
                    ip: window.location.hostname,
                    hostname: 'gateway',
                    spec: 'Ollama Gateway'
                }
            }
        };
        
        // ÂãïÊÖãÂä†ËºâÁØÄÈªûÈÖçÁΩÆ
        async function loadNodeConfig() {
            try {
                const response = await fetch('/nodes');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                
                // Ê∏ÖÁ©∫ÁèæÊúâÈÖçÁΩÆÔºà‰øùÁïô routerÔºâ
                CONFIG.exporterUrls = { router: null };
                CONFIG.nodePositions = { router: { x: 0, y: 0, z: 0 } };
                CONFIG.nodeInfo = {
                    router: CONFIG.nodeInfo.router
                };
                
                const nodes = data.nodes || [];
                const localNodes = nodes.filter(n => n.type === 'local');
                const externalNodes = nodes.filter(n => n.type === 'external');
                
                // ÁÇ∫Êú¨Âú∞ÁØÄÈªûÁîüÊàê exporter URLsÔºàÂÅáË®≠ exporter Âú® 9101 Á´ØÂè£Ôºâ
                localNodes.forEach((node, index) => {
                    const nodeName = node.name;
                    const host = node.hosts && node.hosts.length > 0 ? node.hosts[0] : 'unknown';
                    CONFIG.exporterUrls[nodeName] = `http://${host}:9101/metrics`;
                    
                    // ÂæûÈÖçÁΩÆ‰∏≠ÊèêÂèñ‰ø°ÊÅØ
                    const config = node.config || {};
                    const description = config.description || '';
                    const memoryGb = config.memory_gb || '';
                    
                    CONFIG.nodeInfo[nodeName] = {
                        name: nodeName.toUpperCase(),
                        ip: host,
                        hostname: node.hosts && node.hosts.length > 1 ? node.hosts[1] : host,
                        hostnames: node.hosts && node.hosts.length > 2 ? node.hosts.slice(2) : [],
                        spec: description || (memoryGb ? `${memoryGb}GB` : '')
                    };
                });
                
                // ÁÇ∫Â§ñÈÉ®ÁØÄÈªûÊ∑ªÂä†‰ø°ÊÅØ
                externalNodes.forEach((node, index) => {
                    const nodeName = node.name;
                    CONFIG.exporterUrls[nodeName] = null; // Â§ñÈÉ®ÁØÄÈªûÊ≤íÊúâ exporter
                    
                    const config = node.config || {};
                    const description = config.description || '';
                    
                    CONFIG.nodeInfo[nodeName] = {
                        name: nodeName.toUpperCase(),
                        ip: node.api_url || 'N/A',
                        hostname: 'external',
                        spec: description || 'External API'
                    };
                });
                
                // Ëá™ÂãïÁîüÊàêÁØÄÈªû‰ΩçÁΩÆÔºàÂúìÂΩ¢Â∏ÉÂ±ÄÔºâ
                const allNodes = [...localNodes, ...externalNodes];
                const radius = Math.max(4, Math.ceil(allNodes.length / 2) * 2);
                const angleStep = (2 * Math.PI) / allNodes.length;
                
                allNodes.forEach((node, index) => {
                    const nodeName = node.name;
                    const angle = index * angleStep;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    CONFIG.nodePositions[nodeName] = { x, y: 0, z };
                });
                
                console.log('‚úÖ Loaded node config:', {
                    nodes: allNodes.length,
                    local: localNodes.length,
                    external: externalNodes.length,
                    positions: Object.keys(CONFIG.nodePositions).length
                });
                
                return true;
            } catch (error) {
                console.error('‚ùå Failed to load node config:', error);
                // ‰ΩøÁî®ÈªòË™çÈÖçÁΩÆÔºàÂêëÂæåÂÖºÂÆπÔºâ
                return false;
            }
        }
        
        // Â†¥ÊôØË®≠ÁΩÆ
        let scene, camera, renderer, controls;
        let nodeMeshes = {};
        let edgeLines = {};
        let edgeLabels = {}; // ÈÄ£Êé•Á∑ö‰∏äÁöÑÊ®ôÁ∞Ω
        let detailLabels = {}; // Ë©≥Á¥∞‰ø°ÊÅØÊ®ôÁ∞ΩÔºàhoverÊôÇÈ°ØÁ§∫Ôºâ
        let modelLabels = {}; // Â∑≤Âä†ËºâÊ®°ÂûãÊ®ôÁ∞ΩÔºàÈ°ØÁ§∫Âú®ÁØÄÈªû‰∏ãÊñπÔºâ
        let raycaster, mouse;
        let hoveredNode = null;
        let autoRotate = false;
        let previousData = {}; // ‰øùÂ≠ò‰∏ä‰∏ÄÊ¨°ÁöÑÊï∏ÊìöÁî®ÊñºË®àÁÆó rate
        let loadedModelsData = {}; // ‰øùÂ≠òÂ∑≤Âä†ËºâÊ®°ÂûãÊï∏Êìö
        
        // ÂàùÂßãÂåñ Three.js Â†¥ÊôØ
        function initScene() {
            // ÂâµÂª∫Â†¥ÊôØ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);
            
            // ÂâµÂª∫Áõ∏Ê©ü
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(10, 8, 10);
            camera.lookAt(0, 0, 0);
            
            // ÂâµÂª∫Ê∏≤ÊüìÂô®ÔºàÈ´òË≥™ÈáèË®≠ÁΩÆÔºâ
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // ÈôêÂà∂ÊúÄÂ§ßDPI‰ª•ÈÅøÂÖçÊÄßËÉΩÂïèÈ°å
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ‰ΩøÁî®ËªüÈô∞ÂΩ±
            
            // Ê∑ªÂä†ËªåÈÅìÊéßÂà∂Âô®
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            
            // ÂàùÂßãÂåñÂ∞ÑÁ∑öÊ™¢Ê∏¨Âô®ÔºàÁî®ÊñºhoverÊ™¢Ê∏¨Ôºâ
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Ê∑ªÂä†ÂÖâÊ∫êÔºàÂ∞àÊ•≠Á∂≤Áµ°ÊãìÊí≤È¢®Ê†ºÔºâ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // ÂâµÂª∫ÁØÄÈªû
            createNodes();
            
            // ÂâµÂª∫ÈÄ£Êé•Á∑ö
            createEdges();
            
            // Ê∑ªÂä†Âú∞Èù¢Á∂≤Ê†ºÔºàÁ∂≤Áµ°ÊãìÊí≤È¢®Ê†ºÔºâ
            const gridHelper = new THREE.GridHelper(20, 20, 0xd1d5db, 0xe5e7eb);
            gridHelper.position.y = -0.1;
            scene.add(gridHelper);
            
            // Ê∑ªÂä†Âú∞Èù¢Âπ≥Èù¢
            const planeGeometry = new THREE.PlaneGeometry(30, 30);
            const planeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.8,
                metalness: 0.1
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);
            
            // ÈñãÂßãÂãïÁï´Âæ™Áí∞
            animate();
        }
        
        // ÂâµÂª∫ÊñáÂ≠óÁ¥ãÁêÜÔºàÊîØÊåÅÂ§öË°åÔºåÈ´òË≥™ÈáèÊäóÈã∏ÈΩíÔºåÂûÇÁõ¥È°ØÁ§∫Ôºâ
        function createTextTexture(lines, options = {}) {
            // ‰ΩøÁî®È´òDPI‰æÜÊèêÈ´òÊñáÂ≠óÊ∏ÖÊô∞Â∫¶
            const dpr = window.devicePixelRatio || 2;
            const scale = Math.max(2, dpr); // Ëá≥Â∞ë2ÂÄçÂàÜËæ®Áéá
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d', { 
                alpha: true,
                antialias: true,
                willReadFrequently: false
            });
            
            const fontSize = options.fontSize || 32;
            const smallFontSize = options.smallFontSize || 24;
            const fontFamily = options.fontFamily || 'Arial, sans-serif';
            const fontWeight = options.fontWeight || 'bold';
            const textColor = options.textColor || '#1e40af';
            const smallTextColor = options.smallTextColor || '#6b7280';
            const backgroundColor = options.backgroundColor || 'rgba(255, 255, 255, 0.95)';
            const padding = options.padding || 15;
            const lineHeight = options.lineHeight || 1.3;
            const vertical = options.vertical !== false; // ÈªòË™çÂûÇÁõ¥È°ØÁ§∫
            
            // ÂïüÁî®È´òË≥™ÈáèÊñáÂ≠óÊ∏≤Êüì
            context.textBaseline = 'alphabetic';
            context.textAlign = 'center';
            
            if (vertical) {
                // ÂûÇÁõ¥È°ØÁ§∫ÔºöÂ∞áÊñáÂ≠óÊóãËΩâ90Â∫¶
                // Ë®àÁÆóÊñáÂ≠óÂØ¨Â∫¶ÂíåÈ´òÂ∫¶Ôºà‰ΩøÁî®ÂØ¶ÈöõÂ≠óÈ´îÂ§ßÂ∞èÔºâ
                context.font = `${fontWeight} ${fontSize * scale}px ${fontFamily}`;
                let maxWidth = 0;
                let totalHeight = 0;
                lines.forEach((line, index) => {
                    const font = index === 0 ? 
                        `${fontWeight} ${fontSize * scale}px ${fontFamily}` : 
                        `${smallFontSize * scale}px ${fontFamily}`;
                    context.font = font;
                    const metrics = context.measureText(line.text || line);
                    maxWidth = Math.max(maxWidth, metrics.width);
                    const lineHeightValue = index === 0 ? fontSize * scale : smallFontSize * scale;
                    totalHeight += lineHeightValue * (index === 0 ? 1.1 : lineHeight);
                });
                
                // ÂûÇÁõ¥È°ØÁ§∫ÔºöÂØ¨Â∫¶ÂíåÈ´òÂ∫¶‰∫íÊèõ
                const canvasWidth = totalHeight + padding * 2 * scale;
                const canvasHeight = maxWidth + padding * 2 * scale;
                
                // Ë®≠ÁΩÆÈ´òÂàÜËæ®Áéácanvas
                canvas.width = canvasWidth * 1.1;
                canvas.height = canvasHeight * 1.1;
                canvas.style.width = (canvas.width / scale) + 'px';
                canvas.style.height = (canvas.height / scale) + 'px';
                
                // Á∏ÆÊîæcontext‰ª•ÂåπÈÖçÈ´òÂàÜËæ®Áéá
                context.scale(scale, scale);
                
                // ÂïüÁî®ÊäóÈã∏ÈΩíÂíåÊñáÂ≠óÂπ≥Êªë
                context.imageSmoothingEnabled = true;
                context.imageSmoothingQuality = 'high';
                
                // Áπ™Ë£ΩËÉåÊôØ
                if (backgroundColor) {
                    context.fillStyle = backgroundColor;
                    context.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
                }
                
                // Áπ™Ë£ΩÂûÇÁõ¥ÊñáÂ≠óÔºàÂ§öË°åÔºâ
                let y = padding;
                lines.forEach((line, index) => {
                    const isFirstLine = index === 0;
                    const isTitle = line.isTitle === true;
                    const currentFontSize = (isFirstLine || isTitle) ? fontSize : smallFontSize;
                    const font = (isFirstLine || isTitle) ? 
                        `${fontWeight} ${fontSize}px ${fontFamily}` : 
                        `${smallFontSize}px ${fontFamily}`;
                    const color = (isFirstLine || isTitle) ? textColor : smallTextColor;
                    
                    context.save();
                    
                    // ÁßªÂãïÂà∞ÊñáÂ≠ó‰ΩçÁΩÆ
                    const centerX = canvas.width / scale / 2;
                    context.translate(centerX, y);
                    // ÊóãËΩâ90Â∫¶ÔºàÈ†ÜÊôÇÈáùÔºâ
                    context.rotate(Math.PI / 2);
                    
                    context.font = font;
                    context.fillStyle = color;
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    
                    // ‰ΩøÁî®ÊñáÂ≠óÈô∞ÂΩ±‰æÜÂ¢ûÂº∑Ê∏ÖÊô∞Â∫¶
                    context.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    context.shadowBlur = 1;
                    context.shadowOffsetX = 0.5;
                    context.shadowOffsetY = 0.5;
                    
                    const text = line.text || line;
                    context.fillText(text, 0, 0);
                    
                    context.restore();
                    
                    // ÈáçÁΩÆÈô∞ÂΩ±
                    context.shadowColor = 'transparent';
                    context.shadowBlur = 0;
                    context.shadowOffsetX = 0;
                    context.shadowOffsetY = 0;
                    
                    if (isFirstLine || isTitle) {
                        y += fontSize * 1.1; // Ê®ôÈ°åË°åÈñìË∑ù
                    } else {
                        y += smallFontSize * lineHeight;
                    }
                });
            } else {
                // Ê∞¥Âπ≥È°ØÁ§∫ÔºàÂéüÊúâÈÇèËºØÔºâ
                context.font = `${fontWeight} ${fontSize * scale}px ${fontFamily}`;
                let maxWidth = 0;
                lines.forEach((line, index) => {
                    const font = index === 0 ? 
                        `${fontWeight} ${fontSize * scale}px ${fontFamily}` : 
                        `${smallFontSize * scale}px ${fontFamily}`;
                    context.font = font;
                    const metrics = context.measureText(line.text || line);
                    maxWidth = Math.max(maxWidth, metrics.width);
                });
                
                const totalHeight = (fontSize * scale) + (lines.length - 1) * (smallFontSize * scale * lineHeight);
                
                canvas.width = (maxWidth + padding * 2 * scale) * 1.1;
                canvas.height = (totalHeight + padding * 2 * scale) * 1.1;
                canvas.style.width = (canvas.width / scale) + 'px';
                canvas.style.height = (canvas.height / scale) + 'px';
                
                context.scale(scale, scale);
                context.imageSmoothingEnabled = true;
                context.imageSmoothingQuality = 'high';
                
                if (backgroundColor) {
                    context.fillStyle = backgroundColor;
                    context.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
                }
                
                let y = padding + fontSize;
                lines.forEach((line, index) => {
                    const isFirstLine = index === 0;
                    const isTitle = line.isTitle === true;
                    const font = (isFirstLine || isTitle) ? 
                        `${fontWeight} ${fontSize}px ${fontFamily}` : 
                        `${smallFontSize}px ${fontFamily}`;
                    const color = (isFirstLine || isTitle) ? textColor : smallTextColor;
                    
                    context.font = font;
                    context.fillStyle = color;
                    context.textAlign = 'center';
                    context.textBaseline = 'alphabetic';
                    
                    context.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    context.shadowBlur = 1;
                    context.shadowOffsetX = 0.5;
                    context.shadowOffsetY = 0.5;
                    
                    const text = line.text || line;
                    context.fillText(text, (canvas.width / scale) / 2, y);
                    
                    context.shadowColor = 'transparent';
                    context.shadowBlur = 0;
                    context.shadowOffsetX = 0;
                    context.shadowOffsetY = 0;
                    
                    if (isFirstLine || isTitle) {
                        y += fontSize * 1.1;
                    } else {
                        y += smallFontSize * lineHeight;
                    }
                });
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            texture.needsUpdate = true;
            return texture;
        }
        
        // ÂâµÂª∫ÁØÄÈªûÔºàÊúçÂãôÂô®Ê©üÊû∂È¢®Ê†ºÔºâ
        function createNodes() {
            // ÂãïÊÖãÁç≤ÂèñÊâÄÊúâÁØÄÈªûÂêçÁ®±ÔºàÂåÖÊã¨ routerÔºâ
            const nodeNames = ['router', ...Object.keys(CONFIG.nodePositions).filter(n => n !== 'router')];
            
            nodeNames.forEach(nodeName => {
                if (!CONFIG.nodePositions[nodeName]) {
                    console.warn(`No position defined for node: ${nodeName}`);
                    return;
                }
                const pos = CONFIG.nodePositions[nodeName];
                
                // ÂâµÂª∫ÊúçÂãôÂô®Ê©üÊû∂Ê®£ÂºèÁöÑÁØÄÈªûÔºàÁ´ãÊñπÈ´îÔºâ
                const width = nodeName === 'router' ? 0.8 : 0.6;
                const height = nodeName === 'router' ? 1.2 : 1.0;
                const depth = 0.6;
                
                const geometry = new THREE.BoxGeometry(width, height, depth);
                // Ê™¢Êü•ÊòØÂê¶ÊòØÂ§ñÈÉ®ÁØÄÈªû
                const nodeInfo = CONFIG.nodeInfo[nodeName] || {};
                const isExternal = nodeInfo.spec && nodeInfo.spec.includes('External');
                const baseColor = nodeName === 'router' 
                    ? CONFIG.nodeColors.router 
                    : (isExternal ? CONFIG.nodeColors.external : CONFIG.nodeColors.idle);
                
                const material = new THREE.MeshStandardMaterial({
                    color: baseColor,
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: 0x000000
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pos.x, height / 2, pos.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.nodeName = nodeName;
                scene.add(mesh);
                nodeMeshes[nodeName] = mesh;
                
                // Ê∑ªÂä†È†ÇÈÉ®ÊåáÁ§∫Ááà
                const indicatorGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 16);
                const indicatorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x9ca3af,
                    emissive: 0x000000
                });
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                indicator.position.set(0, height / 2 + 0.05, 0);
                indicator.userData.isIndicator = true;
                mesh.add(indicator);
                
                // ÂâµÂª∫Á∞°ÂñÆÁöÑÁØÄÈªûÂêçÁ®±Ê®ôÁ∞ΩÔºàÂßãÁµÇÈ°ØÁ§∫ÔºåÂè™È°ØÁ§∫ÁØÄÈªûÂêçÁ®±Ôºâ
                // nodeInfo Â∑≤Âú®‰∏äÈù¢ËÅ≤ÊòéÔºåÁõ¥Êé•‰ΩøÁî®
                const displayName = nodeInfo ? nodeInfo.name : nodeName.toUpperCase();
                
                const simpleLabelTexture = createTextTexture([{ text: displayName }], {
                    fontSize: 28,
                    fontFamily: 'Arial, sans-serif',
                    fontWeight: 'bold',
                    textColor: '#1e40af',
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    padding: 8,
                    vertical: false // Ê∞¥Âπ≥È°ØÁ§∫
                });
                
                const simpleLabelMaterial = new THREE.MeshBasicMaterial({
                    map: simpleLabelTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                const simpleLabelGeometry = new THREE.PlaneGeometry(1.0, 0.25);
                const simpleLabel = new THREE.Mesh(simpleLabelGeometry, simpleLabelMaterial);
                simpleLabel.position.set(0, height + 0.35, 0);
                simpleLabel.userData.isLabel = true;
                mesh.add(simpleLabel);
                
                // ÂâµÂª∫Â∑≤Âä†ËºâÊ®°ÂûãÊ®ôÁ∞ΩÔºàÈ°ØÁ§∫Âú®ÁØÄÈªû‰∏ãÊñπÔºåÂàùÂßãÁÇ∫Á©∫Ôºâ
                if (nodeName !== 'router') {
                    const modelLabelTexture = createTextTexture([{ text: '' }], {
                        fontSize: 16,
                        fontFamily: 'Arial, sans-serif',
                        fontWeight: 'normal',
                        textColor: '#059669',
                        backgroundColor: 'rgba(255, 255, 255, 0.9)',
                        padding: 6,
                        vertical: false
                    });
                    
                    const modelLabelMaterial = new THREE.MeshBasicMaterial({
                        map: modelLabelTexture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    
                    const modelLabelGeometry = new THREE.PlaneGeometry(1.5, 0.2);
                    const modelLabel = new THREE.Mesh(modelLabelGeometry, modelLabelMaterial);
                    modelLabel.position.set(0, -height / 2 - 0.3, 0);
                    modelLabel.userData.isModelLabel = true;
                    modelLabel.userData.nodeName = nodeName;
                    mesh.add(modelLabel);
                    modelLabels[nodeName] = modelLabel;
                }
                
                // ÂâµÂª∫Ë©≥Á¥∞‰ø°ÊÅØÊ®ôÁ∞ΩÔºàhoverÊôÇÈ°ØÁ§∫ÔºåÂàùÂßãÈö±ËóèÔºâ
                if (nodeInfo) {
                    const detailLabelLines = [];
                    // Á¨¨‰∏ÄË°åÔºöIPÂú∞ÂùÄÔºàËºÉÂ§ßÔºâ
                    detailLabelLines.push({ text: nodeInfo.ip, isTitle: true });
                    // Á¨¨‰∫åË°åÔºöÁ°¨‰ª∂Ë¶èÊ†º
                    if (nodeInfo.spec) {
                        detailLabelLines.push({ text: nodeInfo.spec, isTitle: false });
                    }
                    // Á¨¨‰∏âË°åÔºö‰∏ªÊ©üÂêç
                    if (nodeInfo.hostname) {
                        detailLabelLines.push({ text: nodeInfo.hostname, isTitle: false });
                    }
                    
                    const detailLabelTexture = createTextTexture(detailLabelLines, {
                        fontSize: 22,
                        smallFontSize: 16,
                        fontFamily: 'Arial, sans-serif',
                        fontWeight: 'bold',
                        textColor: '#1e40af',
                        smallTextColor: '#6b7280',
                        backgroundColor: 'rgba(255, 255, 255, 0.98)',
                        padding: 12,
                        lineHeight: 1.3,
                        vertical: false // Ê∞¥Âπ≥È°ØÁ§∫
                    });
                    
                    const detailLabelMaterial = new THREE.MeshBasicMaterial({
                        map: detailLabelTexture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    
                    const detailLabelWidth = 2.0;
                    const detailLabelHeight = detailLabelLines.length * 0.22 + 0.2;
                    const detailLabelGeometry = new THREE.PlaneGeometry(detailLabelWidth, detailLabelHeight);
                    const detailLabel = new THREE.Mesh(detailLabelGeometry, detailLabelMaterial);
                    // Â∞áË©≥Á¥∞Ê®ôÁ∞ΩÊîæÂú®Á∞°ÂñÆÊ®ôÁ∞Ω‰∏äÊñπÔºåÈÅøÂÖçÈáçÁñä
                    detailLabel.position.set(0, height + 0.35 + detailLabelHeight / 2 + 0.15, 0);
                    detailLabel.visible = false; // ÂàùÂßãÈö±Ëóè
                    detailLabel.userData.isDetailLabel = true;
                    mesh.add(detailLabel);
                    detailLabels[nodeName] = detailLabel;
                }
                
                // Ê∑ªÂä†hoverÊ™¢Ê∏¨
                mesh.userData.isNode = true;
                mesh.userData.nodeName = nodeName;
            });
        }
        
        // ÂâµÂª∫ÈÄ£Êé•Á∑öÔºàÁ∂≤Áµ°Á∑öÈ¢®Ê†ºÔºåÊîØÊåÅÂèØËÆäÁ≤óÁ¥∞Ôºâ
        function createEdges() {
            // ÂãïÊÖãÁç≤ÂèñÊâÄÊúâÁØÄÈªûÂêçÁ®±Ôºà‰∏çÂåÖÊã¨ routerÔºâ
            const nodeNames = Object.keys(CONFIG.nodePositions).filter(n => n !== 'router');
            
            nodeNames.forEach(nodeName => {
                if (!CONFIG.nodePositions[nodeName] || !CONFIG.nodePositions.router) {
                    return;
                }
                const sourcePos = CONFIG.nodePositions[nodeName];
                const targetPos = CONFIG.nodePositions.router;
                
                // Ë®àÁÆóÂÖ©Èªû‰πãÈñìÁöÑË∑ùÈõ¢ÂíåÊñπÂêë
                const start = new THREE.Vector3(sourcePos.x, 0.6, sourcePos.z);
                const end = new THREE.Vector3(targetPos.x, 0.6, targetPos.z);
                const distance = start.distanceTo(end);
                const midPoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                
                // ‰ΩøÁî®CylinderGeometryÂâµÂª∫ÂèØËÆäÁ≤óÁ¥∞ÁöÑÁ∑öÊ¢ù
                const initialRadius = 0.02;
                const cylinderGeometry = new THREE.CylinderGeometry(initialRadius, initialRadius, distance, 8);
                
                // ÊóãËΩâÂúìÊü±È´îÂ∞çÈΩäÂÖ©Èªû
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                const axis = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, direction);
                
                const material = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b,
                    transparent: true,
                    opacity: 0.4,
                    metalness: 0.3,
                    roughness: 0.7
                });
                
                const cylinder = new THREE.Mesh(cylinderGeometry, material);
                cylinder.position.copy(midPoint);
                cylinder.setRotationFromQuaternion(quaternion);
                scene.add(cylinder);
                
                edgeLines[nodeName] = { 
                    mesh: cylinder, 
                    start: start, 
                    end: end, 
                    distance: distance,
                    initialRadius: initialRadius 
                };
                
                // Âú®ÈÄ£Êé•Á∑ö‰∏≠ÈñìÂâµÂª∫ÈÄ£Êé•Êï∏Ê®ôÁ∞Ω
                const labelTexture = createTextTexture([{ text: '0' }], {
                    fontSize: 20,
                    fontFamily: 'Arial, sans-serif',
                    fontWeight: 'bold',
                    textColor: '#ffffff',
                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                    padding: 6,
                    vertical: false // Ê∞¥Âπ≥È°ØÁ§∫
                });
                
                const labelMaterial = new THREE.MeshBasicMaterial({
                    map: labelTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                const labelGeometry = new THREE.PlaneGeometry(0.3, 0.15);
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                label.position.copy(midPoint);
                label.position.y += 0.1; // Á®çÂæÆÊä¨È´ò‰∏ÄÈªû
                label.userData.isEdgeLabel = true;
                scene.add(label);
                edgeLabels[nodeName] = label;
            });
        }
        
        // Êõ¥Êñ∞ÁØÄÈªûÂ§ñËßÄ
        function updateNodes(data) {
            Object.keys(nodeMeshes).forEach(nodeName => {
                const mesh = nodeMeshes[nodeName];
                const nodeData = data[nodeName] || { connections: 0, sentRate: 0, recvRate: 0 };
                
                // Ê†πÊìöÈÄ£Êé•Êï∏Ë™øÊï¥È°èËâ≤ÂíåÊåáÁ§∫Ááà
                const isActive = (nodeData.connections || 0) > 0;
                
                if (nodeName === 'router') {
                    mesh.material.color.setHex(CONFIG.nodeColors.router);
                } else {
                    mesh.material.color.setHex(isActive ? CONFIG.nodeColors.active : CONFIG.nodeColors.idle);
                }
                
                // Êõ¥Êñ∞ÊåáÁ§∫Ááà
                const indicator = mesh.children.find(child => child.userData.isIndicator);
                if (indicator) {
                    indicator.material.color.setHex(isActive ? 0x10b981 : 0x9ca3af);
                    indicator.material.emissive.setHex(isActive ? 0x064e3b : 0x000000);
                }
            });
        }
        
        // Êõ¥Êñ∞ÈÄ£Êé•Á∑öÔºàÂåÖÊã¨Á≤óÁ¥∞ÂíåÊ®ôÁ∞ΩÔºâ
        function updateEdges(data) {
            Object.keys(edgeLines).forEach(nodeName => {
                const edge = edgeLines[nodeName];
                const nodeData = data[nodeName] || { connections: 0, sentRate: 0, recvRate: 0 };
                const totalRate = (nodeData.sentRate || 0) + (nodeData.recvRate || 0);
                const connections = nodeData.connections || 0;
                
                // Ê†πÊìöÊµÅÈáèË™øÊï¥Á∑öÊ¢ùÈ°èËâ≤ÂíåÈÄèÊòéÂ∫¶
                if (totalRate > 0) {
                    edge.mesh.material.color.setHex(0x10b981); // Á∂†Ëâ≤Ë°®Á§∫ÊúâÊµÅÈáè
                    edge.mesh.material.opacity = Math.min(0.4 + totalRate / 50000, 0.9);
                } else {
                    edge.mesh.material.color.setHex(0xf59e0b); // Ê©ôËâ≤Ë°®Á§∫ÁÑ°ÊµÅÈáè
                    edge.mesh.material.opacity = 0.2;
                }
                
                // Ê†πÊìöÁ∏ΩÊµÅÈáèË™øÊï¥Á∑öÊ¢ùÁ≤óÁ¥∞Ôºà0.02 Âà∞ 0.08Ôºâ
                const minRadius = 0.02;
                const maxRadius = 0.08;
                const rateFactor = Math.min(totalRate / 100000, 1); // 100KB/s ÁÇ∫ÊúÄÂ§ßÂÄº
                const radius = minRadius + (maxRadius - minRadius) * rateFactor;
                
                // Êõ¥Êñ∞ÂúìÊü±È´îÁ≤óÁ¥∞
                edge.mesh.scale.set(radius / edge.initialRadius, 1, radius / edge.initialRadius);
                
                // Êõ¥Êñ∞ÈÄ£Êé•Êï∏Ê®ôÁ∞Ω
                if (edgeLabels[nodeName]) {
                    const label = edgeLabels[nodeName];
                    const newTexture = createTextTexture([{ text: connections.toString() }], {
                        fontSize: 20,
                        fontFamily: 'Arial, sans-serif',
                        fontWeight: 'bold',
                        textColor: '#ffffff',
                        backgroundColor: connections > 0 ? 'rgba(16, 185, 129, 0.8)' : 'rgba(0, 0, 0, 0.7)',
                        padding: 6,
                        vertical: false // ÂûÇÁõ¥È°ØÁ§∫
                    });
                    label.material.map.dispose();
                    label.material.map = newTexture;
                    label.material.needsUpdate = true;
                }
            });
        }
        
        // Ëß£Êûê Prometheus metrics
        function parseMetrics(text, nodeName) {
            const data = { connections: 0, sentTotal: 0, recvTotal: 0 };
            const lines = text.split('\n');
            
            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith('#') || !line) return;
                
                // Ëß£Êûê metric - ÊîØÊåÅÂ§öÁ®ÆÊ†ºÂºè
                let match = line.match(/^([a-z_]+)\{([^}]+)\}\s+([0-9.eE+-]+)/);
                if (!match) {
                    // ÂòóË©¶‰∏çÂ∏∂Ê®ôÁ∞ΩÁöÑÊ†ºÂºè
                    match = line.match(/^([a-z_]+)\s+([0-9.eE+-]+)/);
                    if (match) {
                        const metricName = match[1];
                        const value = parseFloat(match[2]);
                        if (metricName === 'ollama_bytes_sent_total') {
                            data.sentTotal = value;
                        } else if (metricName === 'ollama_bytes_recv_total') {
                            data.recvTotal = value;
                        }
                    }
                    return;
                }
                
                const metricName = match[1];
                const labels = match[2];
                const value = parseFloat(match[3]);
                
                // Ëß£Êûê labels
                const nodeMatch = labels.match(/node="([^"]+)"/);
                if (nodeMatch && nodeMatch[1] === nodeName) {
                    if (metricName === 'ollama_connections') {
                        const stateMatch = labels.match(/state="([^"]+)"/);
                        if (stateMatch && stateMatch[1] === 'ESTABLISHED') {
                            data.connections = value;
                        }
                    } else if (metricName === 'ollama_bytes_sent_total') {
                        data.sentTotal = value;
                    } else if (metricName === 'ollama_bytes_recv_total') {
                        data.recvTotal = value;
                    }
                }
            });
            
            return data;
        }
        
        // Áç≤ÂèñÂñÆÂÄã exporter ÁöÑ metrics
        async function fetchSingleExporter(url, nodeName) {
            try {
                const response = await fetch(url, { mode: 'cors' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const text = await response.text();
                const parsed = parseMetrics(text, nodeName);
                
                // Ë®àÁÆó rateÔºàËàá‰∏ä‰∏ÄÊ¨°ÁöÑÂÄºÊØîËºÉÔºâ
                const prev = previousData[nodeName] || { sentTotal: 0, recvTotal: 0 };
                const timeDiff = CONFIG.updateInterval / 1000; // Áßí
                
                const result = {
                    connections: parsed.connections,
                    sentTotal: parsed.sentTotal,
                    recvTotal: parsed.recvTotal,
                    sentRate: Math.max(0, (parsed.sentTotal - prev.sentTotal) / timeDiff),
                    recvRate: Math.max(0, (parsed.recvTotal - prev.recvTotal) / timeDiff)
                };
                
                // ‰øùÂ≠òÁï∂ÂâçÂÄº‰æõ‰∏ãÊ¨°‰ΩøÁî®
                previousData[nodeName] = {
                    sentTotal: parsed.sentTotal,
                    recvTotal: parsed.recvTotal
                };
                
                return result;
            } catch (error) {
                console.warn(`ÁÑ°Ê≥ïÁç≤Âèñ ${nodeName} ÁöÑÊï∏Êìö:`, error);
                return null;
            }
        }
        
        // Áç≤ÂèñÂ∑≤Âä†ËºâÊ®°Âûã
        async function fetchLoadedModels() {
            try {
                const response = await fetch('/nodes/loaded-models');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                loadedModelsData = data;
                updateModelLabels();
            } catch (error) {
                console.warn('ÁÑ°Ê≥ïÁç≤ÂèñÂ∑≤Âä†ËºâÊ®°Âûã:', error);
            }
        }
        
        // Êõ¥Êñ∞Ê®°ÂûãÊ®ôÁ∞Ω
        function updateModelLabels() {
            Object.keys(modelLabels).forEach(nodeName => {
                const label = modelLabels[nodeName];
                const models = loadedModelsData[nodeName]?.models || [];
                
                let text = '';
                if (models.length > 0) {
                    // È°ØÁ§∫Ê®°ÂûãÂàóË°®ÔºåÊúÄÂ§öÈ°ØÁ§∫3ÂÄãÔºåË∂ÖÈÅéÈ°ØÁ§∫ "..."
                    const displayModels = models.slice(0, 3);
                    text = displayModels.join(', ');
                    if (models.length > 3) {
                        text += ` +${models.length - 3}`;
                    }
                } else {
                    text = 'ÁÑ°Ê®°Âûã';
                }
                
                const newTexture = createTextTexture([{ text: text }], {
                    fontSize: 16,
                    fontFamily: 'Arial, sans-serif',
                    fontWeight: 'normal',
                    textColor: models.length > 0 ? '#059669' : '#9ca3af',
                    backgroundColor: 'rgba(255, 255, 255, 0.9)',
                    padding: 6,
                    vertical: false
                });
                
                label.material.map.dispose();
                label.material.map = newTexture;
                label.material.needsUpdate = true;
                
                // Ê†πÊìöÊñáÊú¨Èï∑Â∫¶Ë™øÊï¥Ê®ôÁ∞ΩÂØ¨Â∫¶
                const textWidth = Math.max(1.0, Math.min(2.5, text.length * 0.15));
                label.scale.x = textWidth / 1.5;
            });
        }
        
        // Áç≤ÂèñÊâÄÊúâ metrics Êï∏Êìö
        async function fetchMetrics() {
            const allData = {};
            let successCount = 0;
            
            if (CONFIG.exporterUrls) {
                const promises = Object.entries(CONFIG.exporterUrls).map(async ([nodeName, url]) => {
                    if (!url) {
                        // router ÊàñÂ§ñÈÉ®ÁØÄÈªûÔºàÊ≤íÊúâ exporterÔºâÔºåË®àÁÆóÁ∏ΩÂíå
                        if (nodeName === 'router') {
                            const totalConnections = Object.keys(allData)
                                .filter(k => k !== 'router')
                                .reduce((sum, k) => sum + (allData[k]?.connections || 0), 0);
                            allData[nodeName] = { 
                                connections: totalConnections, 
                                sentRate: 0, 
                                recvRate: 0 
                            };
                        } else {
                            // Â§ñÈÉ®ÁØÄÈªûÊ≤íÊúâ metricsÔºåË®≠ÁΩÆÁÇ∫ 0
                            allData[nodeName] = { 
                                connections: 0, 
                                sentRate: 0, 
                                recvRate: 0 
                            };
                        }
                        return;
                    }
                    
                    const nodeData = await fetchSingleExporter(url, nodeName);
                    if (nodeData) {
                        allData[nodeName] = nodeData;
                        successCount++;
                    } else {
                        allData[nodeName] = { connections: 0, sentRate: 0, recvRate: 0 };
                    }
                });
                
                await Promise.all(promises);
                
                // ÈáçÊñ∞Ë®àÁÆó router ÁöÑÈÄ£Êé•Êï∏
                const totalConnections = Object.keys(allData)
                    .filter(k => k !== 'router' && k.startsWith('node'))
                    .reduce((sum, k) => sum + (allData[k]?.connections || 0), 0);
                if (allData.router) {
                    allData.router.connections = totalConnections;
                }
            }
            
            if (successCount === 0) {
                document.getElementById('status-text').textContent = 
                    `‚ö†Ô∏è ÁÑ°Ê≥ïÈÄ£Êé•Âà∞ exporter | Ê™¢Êü• exporter ÊòØÂê¶ÈÅãË°å`;
            } else {
                document.getElementById('status-text').textContent = 
                    `‚úÖ Â∑≤ÈÄ£Êé• ${successCount} ÂÄãÁØÄÈªû | ÊúÄÂæåÊõ¥Êñ∞: ${new Date().toLocaleTimeString()}`;
            }
            
            updateNodes(allData);
            updateEdges(allData);
            updateInfoPanel(allData);
            
            return allData;
        }
        
        // Êõ¥Êñ∞‰ø°ÊÅØÈù¢Êùø
        function updateInfoPanel(data) {
            const container = document.getElementById('nodes-info');
            container.innerHTML = '';
            
            const nodeNames = ['router', 'node1', 'node2', 'node3', 'node4'];
            nodeNames.forEach(nodeName => {
                const nodeData = data[nodeName] || { connections: 0, sentRate: 0, recvRate: 0 };
                const totalRate = nodeData.sentRate + nodeData.recvRate;
                const nodeInfo = CONFIG.nodeInfo[nodeName] || {};
                
                const div = document.createElement('div');
                div.className = 'node-info';
                
                // ÊßãÂª∫Á°¨‰ª∂‰ø°ÊÅØ
                let hardwareInfo = '';
                if (nodeInfo.spec) {
                    hardwareInfo = `<div class="stat" style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(0,0,0,0.1);">
                        <span class="stat-label" style="font-size: 11px; color: #9ca3af;">Á°¨‰ª∂Ë¶èÊ†º:</span>
                        <span class="stat-value" style="font-size: 11px; color: #2563eb;">${nodeInfo.spec}</span>
                    </div>`;
                }
                
                let hostnameInfo = '';
                if (nodeInfo.hostname) {
                    hostnameInfo = `<div class="stat" style="font-size: 11px;">
                        <span class="stat-label" style="color: #9ca3af;">‰∏ªÊ©üÂêç:</span>
                        <span class="stat-value" style="color: #6b7280;">${nodeInfo.hostname}</span>
                    </div>`;
                }
                
                let hostnamesInfo = '';
                if (nodeInfo.hostnames && nodeInfo.hostnames.length > 0) {
                    hostnamesInfo = `<div class="stat" style="font-size: 10px; margin-top: 2px;">
                        <span class="stat-label" style="color: #9ca3af;">Âà•Âêç:</span>
                        <span class="stat-value" style="color: #6b7280; font-size: 10px;">${nodeInfo.hostnames.join(', ')}</span>
                    </div>`;
                }
                
                div.innerHTML = `
                    <strong>${nodeInfo.name || nodeName.toUpperCase()}</strong>
                    ${nodeInfo.ip ? `<div class="stat" style="font-size: 11px; margin-bottom: 4px;">
                        <span class="stat-label" style="color: #9ca3af;">IP:</span>
                        <span class="stat-value" style="color: #2563eb; font-weight: 600;">${nodeInfo.ip}</span>
                    </div>` : ''}
                    ${hostnameInfo}
                    ${hostnamesInfo}
                    ${hardwareInfo}
                    <div class="stat" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1);">
                        <span class="stat-label">ÈÄ£Êé•Êï∏:</span>
                        <span class="stat-value">${Math.round(nodeData.connections || 0)}</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">ÁôºÈÄÅÈÄüÁéá:</span>
                        <span class="stat-value">${formatBytes(nodeData.sentRate || 0)}/s</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Êé•Êî∂ÈÄüÁéá:</span>
                        <span class="stat-value">${formatBytes(nodeData.recvRate || 0)}/s</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Á∏ΩÊµÅÈáè:</span>
                        <span class="stat-value">${formatBytes(totalRate)}/s</span>
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        // Ê†ºÂºèÂåñÂ≠óÁØÄÊï∏
        function formatBytes(bytes) {
            if (bytes === 0 || isNaN(bytes)) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        // Êõ¥Êñ∞Ê®ôÁ∞ΩÊúùÂêëÔºàËÆìÊ®ôÁ∞ΩÂßãÁµÇÈù¢ÂêëÁõ∏Ê©üÔºâ
        function updateLabels() {
            Object.values(nodeMeshes).forEach(mesh => {
                const label = mesh.children.find(child => child.userData.isLabel);
                if (label) {
                    label.lookAt(camera.position);
                }
                const detailLabel = mesh.children.find(child => child.userData.isDetailLabel);
                if (detailLabel) {
                    detailLabel.lookAt(camera.position);
                }
                const modelLabel = mesh.children.find(child => child.userData.isModelLabel);
                if (modelLabel) {
                    modelLabel.lookAt(camera.position);
                }
            });
            
            // Êõ¥Êñ∞ÈÄ£Êé•Á∑öÊ®ôÁ∞ΩÊúùÂêë
            Object.values(edgeLabels).forEach(label => {
                label.lookAt(camera.position);
            });
        }
        
        // ËôïÁêÜÈº†Ê®ôÁßªÂãïÔºàhoverÊ™¢Ê∏¨Ôºâ
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            // Âè™Ê™¢Ê∏¨ÁØÄÈªûÊú¨Ë∫´Ôºå‰∏çÂåÖÊã¨Â≠êÂ∞çË±°ÔºàÊ®ôÁ∞Ω„ÄÅÊåáÁ§∫ÁáàÁ≠âÔºâ
            const nodeObjects = Object.values(nodeMeshes);
            const intersects = raycaster.intersectObjects(nodeObjects, false);
            
            // Èö±ËóèÊâÄÊúâË©≥Á¥∞Ê®ôÁ∞Ω
            Object.values(detailLabels).forEach(label => {
                label.visible = false;
            });
            
            // È°ØÁ§∫hoverÁöÑÁØÄÈªûÁöÑË©≥Á¥∞Ê®ôÁ∞Ω
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                
                // Á¢∫‰øùÊòØÁØÄÈªûÊú¨Ë∫´
                if (intersected.userData.isNode) {
                    const nodeName = intersected.userData.nodeName;
                    if (detailLabels[nodeName]) {
                        detailLabels[nodeName].visible = true;
                        hoveredNode = nodeName;
                    }
                }
            } else {
                hoveredNode = null;
            }
        }
        
        // ËôïÁêÜÈº†Ê®ôÈªûÊìäÔºàÈ°ØÁ§∫Ê®°ÂûãÂàóË°®Ôºâ
        function onMouseClick(event) {
            // Â¶ÇÊûúÈªûÊìäÁöÑÊòØÊ®°ÊÄÅÊ°ÜÊàñÂÖ∂ÂÖßÂÆπÔºå‰∏çËôïÁêÜÁØÄÈªûÈªûÊìä
            if (event.target.closest('#model-modal')) {
                return;
            }
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const nodeObjects = Object.values(nodeMeshes);
            const intersects = raycaster.intersectObjects(nodeObjects, false);
            
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                
                // Á¢∫‰øùÊòØÁØÄÈªûÊú¨Ë∫´Ôºå‰∏î‰∏çÊòØ router
                if (intersected.userData.isNode) {
                    const nodeName = intersected.userData.nodeName;
                    if (nodeName !== 'router') {
                        showModelModal(nodeName);
                    }
                }
            }
        }
        
        // È°ØÁ§∫Ê®°ÂûãÂàóË°®Ê®°ÊÄÅÊ°Ü
        async function showModelModal(nodeName) {
            const modal = document.getElementById('model-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalBody = document.getElementById('modal-body');
            
            const nodeInfo = CONFIG.nodeInfo[nodeName];
            modalTitle.textContent = `${nodeInfo ? nodeInfo.name : nodeName.toUpperCase()} - Â∑≤‰∏ãËºâÊ®°Âûã`;
            modalBody.innerHTML = '<div class="loading-spinner">ËºâÂÖ•‰∏≠...</div>';
            modal.classList.add('active');
            
            try {
                // ÂêåÊôÇÁç≤ÂèñÂ∑≤‰∏ãËºâÊ®°ÂûãÂíåÂ∑≤Âä†ËºâÊ®°Âûã
                const [tagsResponse, loadedResponse] = await Promise.all([
                    fetch(`/nodes/${nodeName}/tags`),
                    fetch('/nodes/loaded-models')
                ]);
                
                if (!tagsResponse.ok) throw new Error(`HTTP ${tagsResponse.status}`);
                const tagsData = await tagsResponse.json();
                
                // Áç≤ÂèñÂ∑≤Âä†ËºâÊ®°ÂûãÂàóË°®
                let loadedModels = [];
                if (loadedResponse.ok) {
                    const loadedData = await loadedResponse.json();
                    loadedModels = loadedData[nodeName]?.models || [];
                }
                
                const models = tagsData.models || [];
                
                if (models.length === 0) {
                    modalBody.innerHTML = '<div class="empty-state">Ë©≤ÁØÄÈªûÊö´ÁÑ°Â∑≤‰∏ãËºâÁöÑÊ®°Âûã</div>';
                    return;
                }
                
                // Ê†ºÂºèÂåñÊ®°ÂûãÂàóË°®
                let html = '<div class="model-list">';
                models.forEach(model => {
                    const name = model.name || 'Êú™Áü•Ê®°Âûã';
                    const size = model.size ? formatBytes(model.size) : 'Êú™Áü•Â§ßÂ∞è';
                    const modified = model.modified_at ? new Date(model.modified_at).toLocaleString('zh-TW') : 'Êú™Áü•ÊôÇÈñì';
                    const digest = model.digest ? model.digest.substring(0, 12) + '...' : '';
                    
                    // Ê™¢Êü•Ê®°ÂûãÊòØÂê¶Â∑≤Âä†ËºâÂà∞ÂÖßÂ≠ò
                    // ÈúÄË¶ÅÂåπÈÖçÊ®°ÂûãÂêçÁ®±ÔºàÂèØËÉΩÂåÖÂê´tagÔºåÂ¶Ç model:30bÔºâ
                    const isLoaded = loadedModels.some(loadedModel => {
                        // ÂÆåÂÖ®ÂåπÈÖç
                        if (loadedModel === name) return true;
                        
                        // ÊèêÂèñÂü∫Á§éÊ®°ÂûãÂêçÁ®±ÔºàÂéªÊéâtagÔºâ
                        const getBaseName = (modelName) => {
                            const parts = modelName.split(':');
                            return parts[0];
                        };
                        
                        const baseName = getBaseName(name);
                        const loadedBaseName = getBaseName(loadedModel);
                        
                        // Âü∫Á§éÂêçÁ®±ÂåπÈÖçÔºà‰æãÂ¶Ç model Âíå model:30b Ë¶ñÁÇ∫Âêå‰∏ÄÊ®°ÂûãÔºâ
                        if (baseName === loadedBaseName && baseName !== '') {
                            return true;
                        }
                        
                        // ÂèçÂêëÊ™¢Êü•ÔºöÂ¶ÇÊûúÂ∑≤Âä†ËºâÁöÑÊ®°ÂûãÂêçÁ®±ÂåÖÂê´Â∑≤‰∏ãËºâÊ®°ÂûãÂêçÁ®±ÔºàÊàñÂèç‰πãÔºâ
                        if (name.includes(loadedBaseName) || loadedModel.includes(baseName)) {
                            return true;
                        }
                        
                        return false;
                    });
                    
                    const statusBadge = isLoaded 
                        ? '<span class="model-status-badge loaded">Â∑≤Âä†Ëºâ</span>'
                        : '<span class="model-status-badge not-loaded">Êú™Âä†Ëºâ</span>';
                    
                    html += `
                        <div class="model-item">
                            <div class="model-name">
                                ${name}
                                ${statusBadge}
                            </div>
                            <div class="model-details">
                                <div class="model-detail-item">
                                    <span class="model-detail-label">Â§ßÂ∞è:</span>
                                    <span class="model-detail-value">${size}</span>
                                </div>
                                <div class="model-detail-item">
                                    <span class="model-detail-label">‰øÆÊîπÊôÇÈñì:</span>
                                    <span class="model-detail-value">${modified}</span>
                                </div>
                                ${digest ? `<div class="model-detail-item">
                                    <span class="model-detail-label">Digest:</span>
                                    <span class="model-detail-value">${digest}</span>
                                </div>` : ''}
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                modalBody.innerHTML = html;
            } catch (error) {
                console.error('Áç≤ÂèñÊ®°ÂûãÂàóË°®Â§±Êïó:', error);
                modalBody.innerHTML = `<div class="empty-state">ËºâÂÖ•Â§±Êïó: ${error.message}</div>`;
            }
        }
        
        // ÈóúÈñâÊ®°ÂûãÂàóË°®Ê®°ÊÄÅÊ°Ü
        function closeModelModal() {
            const modal = document.getElementById('model-modal');
            modal.classList.remove('active');
        }
        
        // ÈªûÊìäÊ®°ÊÄÅÊ°ÜÂ§ñÈÉ®ÈóúÈñâÔºà‰ΩøÁî®‰∫ã‰ª∂ÂßîË®óÔºåÈÅøÂÖçËàá onMouseClick Ë°ùÁ™ÅÔºâ
        document.getElementById('model-modal')?.addEventListener('click', (event) => {
            if (event.target.id === 'model-modal') {
                closeModelModal();
            }
        });
        
        // ÂãïÁï´Âæ™Áí∞
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                const time = Date.now() * 0.0003;
                camera.position.x = Math.cos(time) * 15;
                camera.position.z = Math.sin(time) * 15;
                camera.position.y = 8;
                camera.lookAt(0, 0, 0);
            }
            
            // Êõ¥Êñ∞Ê®ôÁ∞ΩÊúùÂêë
            updateLabels();
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ÊéßÂà∂ÂáΩÊï∏
        function resetCamera() {
            camera.position.set(10, 8, 10);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }
        
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
        }
        
        // Á™óÂè£Â§ßÂ∞èË™øÊï¥
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Ê∑ªÂä†Èº†Ê®ôÁßªÂãïÂíåÈªûÊìä‰∫ã‰ª∂Áõ£ËÅΩ
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        
        // ÂÖàÂä†ËºâÁØÄÈªûÈÖçÁΩÆÔºåÁÑ∂ÂæåÂàùÂßãÂåñÂ†¥ÊôØ
        async function initialize() {
            document.getElementById('status-text').textContent = 'Ê≠£Âú®Âä†ËºâÁØÄÈªûÈÖçÁΩÆ...';
            const configLoaded = await loadNodeConfig();
            if (configLoaded) {
                document.getElementById('status-text').textContent = 'Ê≠£Âú®ÂàùÂßãÂåñÂ†¥ÊôØ...';
            }
            initScene();
            animate();
            fetchMetrics();
            fetchLoadedModels();
            setInterval(fetchMetrics, CONFIG.updateInterval);
            setInterval(fetchLoadedModels, CONFIG.updateInterval * 2);
        }
        
        initialize();
    </script>
</body>
</html>
